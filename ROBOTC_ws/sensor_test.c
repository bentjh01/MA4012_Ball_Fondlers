#pragma config(Sensor, in1,    long_distance_R, sensorAnalog)
#pragma config(Sensor, in2,    short_distance, sensorAnalog)
#pragma config(Sensor, in3,    long_distance_L, sensorAnalog)
#pragma config(Sensor, in4,    long_distance_top, sensorAnalog)
#pragma config(Sensor, in5,    line_BR,        sensorAnalog)
#pragma config(Sensor, in6,    line_FR,        sensorAnalog)
#pragma config(Sensor, in7,    line_FL,        sensorAnalog)
#pragma config(Sensor, in8,    line_BL,        sensorAnalog)
#pragma config(Sensor, dgtl2,  wheel_L_encoderA, sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  wheel_R_encoderA, sensorQuadEncoder)
#pragma config(Motor,  port2,           servo,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           motor_R,       tmotorVex393_MC29, PIDControl, encoderPort, dgtl4)
#pragma config(Motor,  port7,           motor_L,       tmotorVex393_MC29, PIDControl, reversed, encoderPort, dgtl2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Params
#define dt 0.05
#define PI 3.14159265358979323846

#define CUTOFF_A 	1 // [Hz]
#define ALPHA_A 	1/(2*PI*CUTOFF_A*dt +1)
#define CUTOFF_B 	1 // [Hz]
#define ALPHA_B 	1/(2*PI*CUTOFF_B*dt +1)
#define CUTOFF_C 	1 // [Hz]
#define ALPHA_C 	1/(2*PI*CUTOFF_C*dt +1)
#define CUTOFF_D 	1 // [Hz]
#define ALPHA_D 	1/(2*PI*CUTOFF_D*dt +1)

#define CUTOFF_E 	1 // [Hz]
#define ALPHA_E 	1/(2*PI*CUTOFF_A*dt +1)
#define CUTOFF_F 	1 // [Hz]
#define ALPHA_F 	1/(2*PI*CUTOFF_A*dt +1)
#define CUTOFF_G 	1 // [Hz]
#define ALPHA_G 	1/(2*PI*CUTOFF_A*dt +1)
#define CUTOFF_H 	1 // [Hz]
#define ALPHA_H 	1/(2*PI*CUTOFF_A*dt +1)

// support functions
float low_pass_filter(float input, float prev_input, float alpha){
	return alpha*input + (1-alpha)*prev_input;
}

// global variables
int line_FL_val;
int line_BL_val;
int line_BR_val;
int	line_FR_val;

int prev_line_FL_val;
int prev_line_BL_val;
int prev_line_BR_val;
int	prev_line_FR_val;

int dis_L_val;
int dis_R_val;
int dis_mid_val;
int dis_top_val;

int prev_dis_L_val;
int prev_dis_R_val;
int prev_dis_mid_val;
int prev_dis_top_val;

int enR;
int enL;

float current_time;

// sensors

void read_sensors(){
	prev_line_FL_val = line_FL_val;
	prev_line_BL_val = line_BL_val;
	prev_line_BR_val = line_BR_val;
	prev_line_FR_val = line_FR_val;
	line_FL_val = low_pass_filter(SensorValue[line_FL], prev_line_FL_val, ALPHA_A);
	line_BL_val = low_pass_filter(SensorValue[line_BL], prev_line_BL_val, ALPHA_B);
	line_BR_val = low_pass_filter(SensorValue[line_BR], prev_line_FL_val, ALPHA_C);
	line_FR_val = low_pass_filter(SensorValue[line_FR], prev_line_FL_val, ALPHA_D);

	prev_dis_L_val = dis_L_val;
	prev_dis_R_val = dis_R_val;
	prev_dis_mid_val = dis_mid_val;
	prev_dis_top_val = dis_top_val;
	dis_L_val = low_pass_filter(SensorValue[long_distance_L], prev_dis_L_val, ALPHA_E);
	dis_R_val = low_pass_filter(SensorValue[long_distance_R], prev_dis_R_val, ALPHA_F);
	dis_mid_val = low_pass_filter(SensorValue[short_distance], prev_dis_mid_val, ALPHA_G);
	dis_top_val = low_pass_filter(SensorValue[long_distance_top], prev_dis_top_val, ALPHA_H);

	enR = getMotorEncoder(motor_R);
	enL = getMotorEncoder(motor_L);
	resetMotorEncoder(motor_R);
	resetMotorEncoder(motor_L);
}

void floppy(){
	float num = 5.0;
	float den = 13.0;
	float result = num/den;
}

task main()
{
	resetMotorEncoder(motor_R);
	resetMotorEncoder(motor_L);
	while(1){
		clearTimer(T1);
		read_sensors();
		// Main Loop
		for (unsigned int i = 0; i < 1000; i++){
			floppy();
		}
		motor[motor_L] = 0;
		motor[motor_R] = 0;
		motor[servo] = 0;
		while (time1[T1] < dt * 1000){}
		current_time = time1[T1];
	}
}
