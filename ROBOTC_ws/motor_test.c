#pragma config(Sensor, dgtl2,  wheel_L_encoderA, sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  wheel_R_encoderA, sensorQuadEncoder)
#pragma config(Motor,  port2,           servo,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           motor_R,       tmotorVex393_MC29, PIDControl, encoderPort, dgtl4)
#pragma config(Motor,  port7,           motor_L,       tmotorVex393_MC29, PIDControl, reversed, encoderPort, dgtl2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "config.h"

typedef struct {
	float linear_x;
	float angular_z;
} twist_t;

typedef struct {
	int left;
	int right;
} motor_rpm_t;

/* _____________________________________________________________________________________________________________________

MOTORS
_____________________________________________________________________________________________________________________ */

float calcualte_rpm_L(twist_t twist){
	motor_rpm_t rpm;
	float radian_per_sec = twist.angular_z * DEGREE_TO_RADIAN;
	rpm.right = (twist.linear_x + radian_per_sec*ROBOT_TRACK/2)/(WHEEL_DIAMETER/2);
	rpm.left = (twist.linear_x - radian_per_sec*ROBOT_TRACK/2)/(WHEEL_DIAMETER/2);
	return rpm.left ;
}

float calcualte_rpm_R(twist_t twist){
	motor_rpm_t rpm;
	float radian_per_sec = twist.angular_z * DEGREE_TO_RADIAN;
	rpm.right = (twist.linear_x + radian_per_sec*ROBOT_TRACK/2)/(WHEEL_DIAMETER/2);
	rpm.left = (twist.linear_x - radian_per_sec*ROBOT_TRACK/2)/(WHEEL_DIAMETER/2);
	return rpm.right;
}


float calculate_actual_rpm_L(motor_rpm_t rpm){
	float higher_rpm;
	if (rpm.right > rpm.left){
		higher_rpm = rpm.right;
		} else {
		higher_rpm = rpm.left;
	}
	if (higher_rpm == 0){
		rpm.right= 0;
		rpm.left = 0;
		} else{
		rpm.right= rpm.right/higher_rpm * MAX_WHEEL_RPM;
		rpm.left = rpm.left/higher_rpm * MAX_WHEEL_RPM;
	}

	return rpm.left;
}

float calculate_actual_rpm_R(motor_rpm_t rpm){
	float higher_rpm;
	if (rpm.right > rpm.left){
		higher_rpm = rpm.right;
		} else {
		higher_rpm = rpm.left;
	}
	if (higher_rpm == 0){
		rpm.right= 0;
		rpm.left = 0;
		} else{
		rpm.right= rpm.right/higher_rpm * MAX_WHEEL_RPM;
		rpm.left = rpm.left/higher_rpm * MAX_WHEEL_RPM;
	}

	return rpm.right;
}

float calculate_actual_linear_x(motor_rpm_t rpm){
	twist_t twist;
	twist.linear_x = (rpm.right + rpm.left) * WHEEL_DIAMETER/4;
	twist.angular_z = (rpm.right - rpm.left) * WHEEL_DIAMETER/ROBOT_TRACK;
	return twist.linear_x;
}

float calculate_actual_angular_z(motor_rpm_t rpm){
	twist_t twist;
	twist.linear_x = (rpm.right + rpm.left) * WHEEL_DIAMETER/4;
	twist.angular_z = (rpm.right - rpm.left) * WHEEL_DIAMETER/ROBOT_TRACK;
	return twist.angular_z;
}

// void robot_move(motor_rpm_t rpm){
void robot_move(float rpm_R, float rpm_L){
	int motor_power_R = rpm_R/MAX_WHEEL_RPM * 127;
	int motor_power_L = rpm_L/MAX_WHEEL_RPM * 127;
	motor[motor_R] = motor_power_R;
	motor[motor_L] = motor_power_L;
	return;
}

twist_t robot_twist;
motor_rpm_t robot_rpm;

int d_enR;
int d_enL;

int m_rpmR;
int m_rpmL;

float linX;
float angZ;
float rpmR;
float rpmL;

unsigned int counter;

void motor_test(){
	twist_t twist;
	motor_rpm_t rpm;
	if (counter < 100){
		linX = 1;
		angZ = 0.0;
	}
	else {
		linX = 0.0;
		angZ = 0.0;
	}
	twist.linear_x = linX;
	twist.angular_z = angZ;
	rpmL = calcualte_rpm_L(twist);
	rpmR = calcualte_rpm_R(twist);
	rpm.left = rpmL;
	rpm.right = rpmR;
	// rpmL = calculate_actual_rpm_L(rpm);
	// rpmR = calculate_actual_rpm_R(rpm);
	// rpm.left = calculate_actual_rpm_L(rpm);
	// rpm.right = calculate_actual_rpm_R(rpm);
	// linX = calculate_actual_linear_x(robot_rpm);
	// angZ = calculate_actual_angular_z(robot_rpm);
	// twist.linear_x = calculate_actual_linear_x(robot_rpm);
	// twist.angular_z = calculate_actual_angular_z(robot_rpm);
	robot_move(rpmR, rpmL);
	// robot_twist = twist;
	// robot_rpm = rpm;
	// linX = robot_twist.linear_x;
	// angZ = robot_twist.angular_z;
	// rpmL = robot_rpm.left;
	// rpmR = robot_rpm.right;
}

void read_sensors(){
	d_enR = getMotorEncoder(motor_R);
	d_enL = getMotorEncoder(motor_L);
	resetMotorEncoder(motor_R);
	resetMotorEncoder(motor_L);

	m_rpmR = getMotorVelocity(motor_R);
  m_rpmL = getMotorVelocity(motor_L);
}

task main()
{
	resetMotorEncoder(motor_R);
	resetMotorEncoder(motor_L);
	counter = 0;
	while(1){
		clearTimer(T1);
		read_sensors();
		// Main Loop

		motor_test();

		while (time1[T1] < DT * 1000){}
		counter ++;
	}
}
