#pragma config(Sensor, dgtl2,  wheel_L_encoderA, sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  wheel_R_encoderA, sensorQuadEncoder)
#pragma config(Motor,  port2,           servo,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           motor_R,       tmotorVex393_MC29, PIDControl, encoderPort, dgtl4)
#pragma config(Motor,  port7,           motor_L,       tmotorVex393_MC29, PIDControl, reversed, encoderPort, dgtl2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "config.h"

/* _____________________________________________________________________________________________________________________

SENSORS
_____________________________________________________________________________________________________________________ */

int d_enR;
int d_enL;

int m_rpmR;
int m_rpmL;

float cmd_linX;
float cmd_angZ;
float cmd_rpmR;
float cmd_rpmL;

unsigned int counter;

void read_sensors(){
	d_enR = getMotorEncoder(motor_R);
	d_enL = getMotorEncoder(motor_L);

    m_rpmR = d_enR/ENCODER_RESOLUTION * 60/DT;
    m_rpmL = d_enR/ENCODER_RESOLUTION * 60/DT;

	resetMotorEncoder(motor_R);
	resetMotorEncoder(motor_L);
}

/* _____________________________________________________________________________________________________________________

MOTORS CONTROL
_____________________________________________________________________________________________________________________ */

float motor_R_Kp = 0.5;
float motor_R_Ki = 0.5;
float motor_R_Kd = 0.5;
float motor_R_integral = 0;
float motor_R_prev_error = 0;

float motor_L_Kp = 0.5;
float motor_L_Ki = 0.5;
float motor_L_Kd = 0.5;
float motor_L_integral = 0;
float motor_L_prev_error = 0;

float calcualte_rpm_L(float linX, float angZ){
	float radian_per_sec = angZ * DEGREE_TO_RADIAN;
	float rpmR = (linX + radian_per_sec*ROBOT_TRACK/2)/(WHEEL_DIAMETER/2);
	float rpmL = (linX - radian_per_sec*ROBOT_TRACK/2)/(WHEEL_DIAMETER/2);
	return rpmL ;
}

float calcualte_rpm_R(float linX, float angZ){
	float radian_per_sec = angZ * DEGREE_TO_RADIAN;
	float rpmR = (linX + radian_per_sec*ROBOT_TRACK/2)/(WHEEL_DIAMETER/2);
	float rpmL = (linX - radian_per_sec*ROBOT_TRACK/2)/(WHEEL_DIAMETER/2);
	return rpmR;
}

float calculate_actual_rpm_L(float rpmR, float rpmL){
	float higher_rpm;
	if (rpmR > rpmL){
		higher_rpm = rpmR;
		} else {
		higher_rpm = rpmL;
	}
	if (higher_rpm == 0){
		rpmR= 0;
		rpmL = 0;
		} else{
		rpmR= rpmR/higher_rpm * MAX_WHEEL_RPM;
		rpmL = rpmL/higher_rpm * MAX_WHEEL_RPM;
	}

	return rpmL;
}

float calculate_actual_rpm_R(float rpmR, float rpmL){
	float higher_rpm;
	if (rpmR > rpmL){
		higher_rpm = rpmR;
		} else {
		higher_rpm = rpmL;
	}
	if (higher_rpm == 0){
		rpmR= 0;
		rpmL = 0;
		} else{
		rpmR= rpmR/higher_rpm * MAX_WHEEL_RPM;
		rpmL = rpmL/higher_rpm * MAX_WHEEL_RPM;
	}

	return rpmR;
}

float calculate_actual_linear_x(float rpm_R, float rpm_L){
	float linX = (rpm_R + rpm_L) * WHEEL_DIAMETER/4;
	// angZ= (rpmR - rpmL) * WHEEL_DIAMETER/ROBOT_TRACK;
	return linX;
}

float calculate_actual_angular_z(float rpm_R, float rpm_L){
	// linX = (rpmR + rpmL) * WHEEL_DIAMETER/4;
	float angZ = (rpm_R - rpm_L) * WHEEL_DIAMETER/ROBOT_TRACK;
	return angZ;
}

float pid_R(float rpmR, float setpointR){
    float error = setpointR - rpmR;
    motor_R_integral = motor_R_integral + error * DT;
    float derivative = (error - motor_R_prev_error) / DT;
    float output = motor_R_Kp * error + motor_R_Ki * motor_R_integral + motor_R_Kd * derivative;
    motor_R_prev_error = error;
    return output;
}

float pid_L(float rpmL, float setpointL){
    float error = setpointL - rpmL;
    motor_L_integral = motor_L_integral + error * DT;
    float derivative = (error - motor_L_prev_error) / DT;
    float output = motor_L_Kp * error + motor_L_Ki * motor_L_integral + motor_L_Kd * derivative;
    motor_L_prev_error = error;
    return output;
}

// void robot_move(float rpmR, float rpmL){
void robot_move(float rpm_R, float rpm_L){
	int motor_power_R = pid_R(m_rpmR, rpm_R);
	int motor_power_L = pid_L(m_rpmL, rpm_L);
	motor[motor_R] = motor_power_R;
	motor[motor_L] = motor_power_L;
}

void motor_test(){
	if (counter < 100){
		cmd_linX = 1;
		cmd_angZ = 0.0;
	}
	else {
		cmd_linX = 0.0;
		cmd_angZ = 0.0;
	}
	cmd_rpmL = calcualte_rpm_L(cmd_linX, cmd_angZ);
	cmd_rpmR = calcualte_rpm_R(cmd_linX, cmd_angZ);
	cmd_rpmL = calculate_actual_rpm_L(cmd_rpmR, cmd_rpmL);
	cmd_rpmR = calculate_actual_rpm_R(cmd_rpmR, cmd_rpmL);
	cmd_linX = calculate_actual_linear_x(cmd_rpmR, cmd_rpmL);
    cmd_angZ = calculate_actual_angular_z(cmd_rpmR, cmd_rpmL);
	robot_move(cmd_rpmR, cmd_rpmL);
}

task main()
{
	resetMotorEncoder(motor_R);
	resetMotorEncoder(motor_L);
	counter = 0;
	while(1){
		clearTimer(T1);
		read_sensors();
		// Main Loop

		motor_test();

		while (time1[T1] < DT * 1000){}
		counter ++;
	}
}
