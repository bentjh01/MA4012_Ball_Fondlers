#pragma config(Sensor, dgtl2,  wheel_L_encoderA, sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  wheel_R_encoderA, sensorQuadEncoder)
#pragma config(Motor,  port2,           servo,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           motor_R,       tmotorVex393_MC29, PIDControl, encoderPort, dgtl4)
#pragma config(Motor,  port7,           motor_L,       tmotorVex393_MC29, PIDControl, reversed, encoderPort, dgtl2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "config.h"
#include "motors.c"
#include "pid.c"


/* _____________________________________________________________________________________________________________________

SENSORS
_____________________________________________________________________________________________________________________ */

int d_enR;
int d_enL;

float m_rpmR;
float m_rpmL;

float m_linX;
float m_angZ;

float cmd_linX;
float cmd_angZ;
float cmd_rpmR;
float cmd_rpmL;

unsigned int counter;

void read_sensors(){

	d_enR = getMotorEncoder(motor_R);
	d_enL = getMotorEncoder(motor_L);

	m_rpmR = d_enR * 60/DT /ENCODER_RESOLUTION;
  	m_rpmL = d_enL * 60/DT /ENCODER_RESOLUTION;

	m_linX = calculate_linear_x(m_rpmR, m_rpmL);
	m_angZ = calculate_angular_z(m_rpmR, m_rpmL);

	resetMotorEncoder(motor_R);
	resetMotorEncoder(motor_L);
}

/* _____________________________________________________________________________________________________________________

MOTORS CONTROL
_____________________________________________________________________________________________________________________ */


void robot_move(float rpm_R, float rpm_L){
	int motor_power_R = pid_R(m_rpmR, rpm_R);
	int motor_power_L = pid_L(m_rpmL, rpm_L);
	motor[motor_R] = motor_power_R;
	motor[motor_L] = motor_power_L;
}

/* _____________________________________________________________________________________________________________________

TEST SCRIPT
_____________________________________________________________________________________________________________________ */

void motor_test(){
	if (counter < 1000){
		cmd_linX = 1;
		cmd_angZ = 0.0;
	}
	else {
		cmd_linX = 0.0;
		cmd_angZ = 0.0;
	}
	// cmd_rpmL = calcualte_rpm_L(cmd_linX, cmd_angZ);
	// cmd_rpmR = calcualte_rpm_R(cmd_linX, cmd_angZ);
	cmd_rpmL = 30;
	cmd_rpmR = 30;
	// cmd_rpmL = calculate_actual_rpm_L(cmd_rpmR, cmd_rpmL);
	// cmd_rpmR = calculate_actual_rpm_R(cmd_rpmR, cmd_rpmL);
	// cmd_linX = calculate_actual_linear_x(cmd_rpmR, cmd_rpmL);
    // cmd_angZ = calculate_actual_angular_z(cmd_rpmR, cmd_rpmL);
	robot_move(cmd_rpmR, cmd_rpmL);
}

task main()
{
	resetMotorEncoder(motor_R);
	resetMotorEncoder(motor_L);
	counter = 0;
	while(1){
		clearTimer(T1);
		read_sensors();
		// Main Loop

		motor_test();

		while (time1[T1] < DT * 1000){}
		counter ++;
	}
}
