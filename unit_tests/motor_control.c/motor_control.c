#pragma config(Sensor, dgtl2,  wheel_L_encoderA, sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  wheel_R_encoderA, sensorQuadEncoder)
#pragma config(Motor,  port2,           servo,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           motor_R,       tmotorVex393_MC29, PIDControl, encoderPort, dgtl4)
#pragma config(Motor,  port7,           motor_L,       tmotorVex393_MC29, PIDControl, reversed, encoderPort, dgtl2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "motor_control.h"
#include "motor.c"
#include "controller.c"


/* _____________________________________________________________________________________________________________________

SENSORS
_____________________________________________________________________________________________________________________ */

int robot_d_enR;
int robot_d_enL;

float robot_en_rpmR;
float robot_en_rpmL;

float robot_en_linX;
float robot_en_angZ;

float robot_cmd_linX;
float robot_cmd_angZ;
float robot_cmd_rpmR;
float robot_cmd_rpmL;

int loop_ms;

void read_sensors(){

	robot_d_enR = getMotorEncoder(motor_R);
	robot_d_enL = getMotorEncoder(motor_L);

	robot_en_rpmR = robot_d_enR * 60/DT /ENCODER_RESOLUTION;
  	robot_en_rpmL = robot_d_enL * 60/DT /ENCODER_RESOLUTION;

	robot_en_linX = calculate_linear_x(robot_en_rpmR, robot_d_enL);
	robot_en_angZ = calculate_angular_z(robot_en_rpmR, robot_d_enL);

	resetMotorEncoder(motor_R);
	resetMotorEncoder(motor_L);
}

/* _____________________________________________________________________________________________________________________

MOTORS CONTROL
_____________________________________________________________________________________________________________________ */


void robot_move_open(float rpmR, float rpmL){
	motor[motor_R] = rpmR / MAX_WHEEL_RPM * 127;
	motor[motor_L] = rpmL / MAX_WHEEL_RPM * 127;
}

void robot_move_control(float en_rpmR, float en_rpmL, float cmd_rpmR, float cmd_rpmL){
	int motor_power_R = pid_R(en_rpmR, cmd_rpmR);
	int motor_power_L = pid_L(en_rpmL, cmd_rpmL);
	motor[motor_R] = motor_power_R;
	motor[motor_L] = motor_power_L;
}

/* _____________________________________________________________________________________________________________________

TEST SCRIPT
_____________________________________________________________________________________________________________________ */

void motor_test(){
	// Sets the motor to a constant speed in an open loop
	robot_cmd_linX = 0.04;
	robot_cmd_angZ = 0.0;
	robot_cmd_rpmR = calcualte_rpmR(robot_cmd_linX, robot_cmd_angZ);
	robot_cmd_rpmL = calcualte_rpmL(robot_cmd_linX, robot_cmd_angZ);
	robot_cmd_rpmR = limit_rpmR(robot_cmd_rpmR, robot_cmd_rpmL);
	robot_cmd_rpmL = limit_rpmL(robot_cmd_rpmR, robot_cmd_rpmL);
	
	robot_cmd_linX = calculate_linX(robot_cmd_rpmR, robot_cmd_rpmL);
    robot_cmd_angZ = calculate_angZ(robot_cmd_rpmR, robot_cmd_rpmL);
	robot_move_open(robot_cmd_rpmR, robot_cmd_rpmL);
}

void tune_pid(void){
	// Sets the motor to a constant speed of 60 [rpm] and activates the PID controller
	robot_cmd_rpmR = 60;
	robot_cmd_rpmL = 60;
	robot_move_closed(robot_en_rpmR, robot_en_rpmL, robot_cmd_rpmR, robot_cmd_rpmL);
}

task main()
{
	resetMotorEncoder(motor_R);
	resetMotorEncoder(motor_L);
	counter = 0;
	while(1){
		clearTimer(T1);
		read_sensors();
		// Main Loop
		// Simulating whole robot task as 1000 flops which is assumed to be 1000 lines of code
		for (unsigned int i = 0; i < 1000; i++){
			floppy();
		}

		motor_test();

		while (time1[T1] < DT * 1000){}
		loop_ms = time1[T1];
	}
}
