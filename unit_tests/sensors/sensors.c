#pragma config(Sensor, in1,    long_distance_R, sensorAnalog)
#pragma config(Sensor, in2,    short_distance, sensorAnalog)
#pragma config(Sensor, in3,    long_distance_L, sensorAnalog)
#pragma config(Sensor, in4,    long_distance_top, sensorAnalog)
#pragma config(Sensor, in5,    line_BR,        sensorAnalog)
#pragma config(Sensor, in6,    line_FR,        sensorAnalog)
#pragma config(Sensor, in7,    line_FL,        sensorAnalog)
#pragma config(Sensor, in8,    line_BL,        sensorAnalog)
#pragma config(Sensor, dgtl2,  wheel_L_encoderA, sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  wheel_R_encoderA, sensorQuadEncoder)
#pragma config(Motor,  port2,           servo,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           motor_R,       tmotorVex393_MC29, PIDControl, encoderPort, dgtl4)
#pragma config(Motor,  port7,           motor_L,       tmotorVex393_MC29, PIDControl, reversed, encoderPort, dgtl2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "sensors.h"

// support functions
float low_pass_filter(float input, float prev_input, float cutoff){
	float alpha = 1/(2*M_PI*cutoff*DT +1);
	return alpha*input + (1-alpha)*prev_input;
}

// global variables
int line_FL_val;
int line_BL_val;
int line_BR_val;
int	line_FR_val;

int prev_line_FL_val;
int prev_line_BL_val;
int prev_line_BR_val;
int	prev_line_FR_val;

int dis_L_val;
int dis_R_val;
int dis_mid_val;
int dis_top_val;

int prev_dis_L_val;
int prev_dis_R_val;
int prev_dis_mid_val;
int prev_dis_top_val;

int d_enR;
int d_enL;
float m_rpmR;
float m_rpmL;

int loop_ms;

// sensors

void read_sensors(){
	prev_line_FL_val = line_FL_val;
	prev_line_BL_val = line_BL_val;
	prev_line_BR_val = line_BR_val;
	prev_line_FR_val = line_FR_val;
	line_FL_val = low_pass_filter(SensorValue[line_FL], prev_line_FL_val, CUTOFF_LINE_FL);
	line_BL_val = low_pass_filter(SensorValue[line_BL], prev_line_BL_val, CUTOFF_LINE_BL);
	line_BR_val = low_pass_filter(SensorValue[line_BR], prev_line_FL_val, CUTOFF_LINE_BR);
	line_FR_val = low_pass_filter(SensorValue[line_FR], prev_line_FL_val, CUTOFF_LINE_FR);

	prev_dis_L_val = dis_L_val;
	prev_dis_R_val = dis_R_val;
	prev_dis_mid_val = dis_mid_val;
	prev_dis_top_val = dis_top_val;
	dis_L_val = low_pass_filter(SensorValue[long_distance_L], prev_dis_L_val, CUTOFF_LONG_L);
	dis_R_val = low_pass_filter(SensorValue[long_distance_R], prev_dis_R_val, CUTOFF_LONG_R);
	dis_mid_val = low_pass_filter(SensorValue[short_distance], prev_dis_mid_val, CUTOFF_SHORT);
	dis_top_val = low_pass_filter(SensorValue[long_distance_top], prev_dis_top_val, CUTOFF_LONG_T);

	d_enR = getMotorEncoder(motor_R);
	d_enL = getMotorEncoder(motor_L);
	m_rpmR = d_enR * 60/DT /ENCODER_RESOLUTION;
  	m_rpmL = d_enL * 60/DT /ENCODER_RESOLUTION;

	resetMotorEncoder(motor_R);
	resetMotorEncoder(motor_L);
}

void floppy(){
	float num = 5.0;
	float den = 13.0;
	float result = num/den;
}

void some_function (int a, int b, some_struct &test_struct){
	test_struct.a = test_struct.a + a;
	test_struct.b = test_struct.b + b;
}

task main()
{
	some_function(2, 3, this_struct);
	resetMotorEncoder(motor_R);
	resetMotorEncoder(motor_L);
	while(1){
		clearTimer(T1);
		read_sensors();

		struct_a = this_struct.a;
		struct_b = this_struct.b;

		// Main Loop
		// Simulating whole robot task as 1000 flops which is assumed to be 1000 lines of code
		for (unsigned int i = 0; i < 1000; i++){
			floppy();
		}
		some_function(1, 1, this_struct);
		motor[motor_L] = 0;
		motor[motor_R] = 0;
		motor[servo] = 0;
		while (time1[T1] < dt * 1000){}
		loop_ms = time1[T1];
	}
}
