#pragma config(Sensor, in1,    long_distance_R, sensorAnalog)
#pragma config(Sensor, in2,    short_distance, sensorAnalog)
#pragma config(Sensor, in3,    long_distance_L, sensorAnalog)
#pragma config(Sensor, in4,    long_distance_top, sensorAnalog)
#pragma config(Sensor, in5,    line_BR,        sensorAnalog)
#pragma config(Sensor, in6,    line_FR,        sensorAnalog)
#pragma config(Sensor, in7,    line_FL,        sensorAnalog)
#pragma config(Sensor, in8,    line_BL,        sensorAnalog)
#pragma config(Sensor, dgtl2,  wheel_L_encoderA, sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  wheel_R_encoderA, sensorQuadEncoder)
#pragma config(Motor,  port2,           servo,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           motor_R,       tmotorVex393_MC29, PIDControl, encoderPort, dgtl4)
#pragma config(Motor,  port7,           motor_L,       tmotorVex393_MC29, PIDControl, reversed, encoderPort, dgtl2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "sensors.h"
#include "filter.c"

// global variables
int line_FL_val;
int line_BL_val;
int line_BR_val;
int	line_FR_val;

int prev_line_FL_val;
int prev_line_BL_val;
int prev_line_BR_val;
int	prev_line_FR_val;

int dis_L_val;
int dis_R_val;
int dis_mid_val;
int dis_top_val;

int prev_dis_L_val;
int prev_dis_R_val;
int prev_dis_mid_val;
int prev_dis_top_val;

int d_enR;
int d_enL;
float m_rpmR;
float m_rpmL;

int loop_ms;

// sensors
/**
 * @brief Updates all sensor values
*/
void read_sensors(){
	prev_line_FL_val = line_FL_val;
	prev_line_BL_val = line_BL_val;
	prev_line_BR_val = line_BR_val;
	prev_line_FR_val = line_FR_val;
	line_FL_val = low_pass_filter(SensorValue[line_FL], prev_line_FL_val, CUTOFF_LINE_FL);
	line_BL_val = low_pass_filter(SensorValue[line_BL], prev_line_BL_val, CUTOFF_LINE_BL);
	line_BR_val = low_pass_filter(SensorValue[line_BR], prev_line_FL_val, CUTOFF_LINE_BR);
	line_FR_val = low_pass_filter(SensorValue[line_FR], prev_line_FL_val, CUTOFF_LINE_FR);

	prev_dis_L_val = dis_L_val;
	prev_dis_R_val = dis_R_val;
	prev_dis_mid_val = dis_mid_val;
	prev_dis_top_val = dis_top_val;
	dis_L_val = low_pass_filter(SensorValue[long_distance_L], prev_dis_L_val, CUTOFF_LONG_L);
	dis_R_val = low_pass_filter(SensorValue[long_distance_R], prev_dis_R_val, CUTOFF_LONG_R);
	dis_mid_val = low_pass_filter(SensorValue[short_distance], prev_dis_mid_val, CUTOFF_SHORT);
	dis_top_val = low_pass_filter(SensorValue[long_distance_top], prev_dis_top_val, CUTOFF_LONG_T);

	d_enR = getMotorEncoder(motor_R);
	d_enL = getMotorEncoder(motor_L);
	m_rpmR = d_enR * 60/DT /ENCODER_RESOLUTION;
  	m_rpmL = d_enL * 60/DT /ENCODER_RESOLUTION;

	resetMotorEncoder(motor_R);
	resetMotorEncoder(motor_L);
}

/**
 * @brief Initialises the robot
*/
void init(){
	resetMotorEncoder(motor_R);
	resetMotorEncoder(motor_L);
}

/**
 * @brief Simulates a robot task by floating point operations
 * @param n number of operations
*/
void floppy(int n){
	for (unsigned int i = 0; i < n; i++){
	float ans = 5.0 / 13.0;
	}
}

task main()
{
	init();
	while(1){
		clearTimer(T1);
		read_sensors();
		// Main Loop
		floppy(1000);

		while (time1[T1] < DT * 1000){}
		loop_ms = time1[T1];
	}
}
