#pragma config(Sensor, in1,    long_distance_R_pin, sensorAnalog)
#pragma config(Sensor, in2,    long_distance_M_pin, sensorAnalog)
#pragma config(Sensor, in3,    long_distance_L_pin, sensorAnalog)
#pragma config(Sensor, in4,    short_distance_T_pin, sensorAnalog)
#pragma config(Sensor, in5,    line_BR_pin,        sensorAnalog)
#pragma config(Sensor, in6,    line_FR_pin,        sensorAnalog)
#pragma config(Sensor, in7,    line_FL_pin,        sensorAnalog)
#pragma config(Sensor, in8,    line_BL_pin,        sensorAnalog)
#pragma config(Sensor, dgtl1,  wheel_L_encoderA_pin, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  wheel_R_encoderA_pin, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  limit_switch_A_pin,      sensorDigitalIn)
#pragma config(Sensor, dgtl6,  limit_switch_B_pin,      sensorDigitalIn)
#pragma config(Sensor, dgtl7,  limit_switch_C_pin,      sensorDigitalIn)
#pragma config(Sensor, dgtl8,  limit_switch_D_pin,      sensorDigitalIn)
#pragma config(Sensor, dgtl9,  magneto_north_pin,  sensorDigitalIn)
#pragma config(Sensor, dgtl10, magneto_south_pin,  sensorDigitalIn)
#pragma config(Sensor, dgtl11, magneto_east_pin,   sensorDigitalIn)
#pragma config(Sensor, dgtl12, magneto_west_pin,   sensorDigitalIn)
#pragma config(Motor,  port2,           servo,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           motor_R,       tmotorVex393_MC29, PIDControl, encoderPort, dgtl3)
#pragma config(Motor,  port7,           motor_L,       tmotorVex393_MC29, PIDControl, reversed, encoderPort, dgtl1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "sensors.h"
#include "filter.c"

// global variables
static float line_FL_val;
static float line_BL_val;
static float line_BR_val;
static float line_FR_val;

static float dis_L_val;
static float dis_R_val;
static float dis_mid_val;
static float dis_top_val;

static float cm_dis_mid_val;
static float cm_dis_top_val;
static float cm_dis_R_val;
static float cm_dis_L_val;

static int d_enR;
static int d_enL;
static float m_rpmR;
static float m_rpmL;

static int limit_switch_A;
static int limit_switch_B;
static int limit_switch_C;
static int limit_switch_D;

static float compass_yaw;

static int loop_ms; // ensure loop runs at 50ms

// float read_compass(void){
//   int combination = SensorValue[compass_south] << 3 + SensorValue[compass_east]  << 2 + SensorValue[compass_north]  << 1 + SensorValue[compass_west];
//   switch (combination)
//   {
//   case 0b1101:
//     return DEG_TO_180(NORTH - MAGNETOMETER_OFFSET);
//   case 0b1001:
//     return DEG_TO_180(NORTH_EAST - MAGNETOMETER_OFFSET);
//   case 0b1011:
//     return DEG_TO_180(EAST - MAGNETOMETER_OFFSET);
//   case 0b0011:
//     return DEG_TO_180(SOUTH_EAST - MAGNETOMETER_OFFSET);
//   case 0b0111:
//     return DEG_TO_180(SOUTH - MAGNETOMETER_OFFSET);
//   case 0b0110:
//     return DEG_TO_180(SOUTH_WEST - MAGNETOMETER_OFFSET);
//   case 0b1110:
//     return DEG_TO_180(WEST - MAGNETOMETER_OFFSET);
//   case 0b1100:
//     return DEG_TO_180(SOUTH - MAGNETOMETER_OFFSET);
//   default:
//     return NULL;
//   }
// }

float calculate_long_distance(float sensor_val){
  //convert voltage reading from long dist sensor into distance in cm
  float voltage = sensor_val / 1000.0;//* BYTE_TO_VOLT;

  //step-by-step calculation as arduino cannot handle PEMDAS
  float ln_voltage = log(voltage);
  float ln_voltage_square = ln_voltage*ln_voltage;
  float term_1 = 29.971*ln_voltage;
  float term_2 = 55.047*ln_voltage_square;
  float term_3 = 57.931*voltage;
  float distance_cm = term_1 + term_2 - term_3 + 84.019;
  return distance_cm;
}

float calculate_short_distance(float sensor_val){
  //convert voltage reading from short dist sensor into distance in cm
  float voltage = sensor_val / 1000.0;//* BYTE_TO_VOLT;

  //calculation for the short distance sensor here
  float exponent = -1/0.95;
  float base = voltage/11.033;
  float distance_cm = pow(base, exponent);
  return distance_cm;
}

// sensors
/**
 * @brief Updates all sensor values
*/
void read_sensors(){
	line_FL_val = filter_line_FL(SensorValue[line_FL_pin]);
	line_BL_val = filter_line_BL(SensorValue[line_BL_pin]);
	line_BR_val = filter_line_BR(SensorValue[line_BR_pin]);
	line_FR_val = filter_line_FR(SensorValue[line_FR_pin]);

	dis_L_val = filter_distance_L(SensorValue[long_distance_L_pin]);
	dis_R_val = filter_distance_R(SensorValue[long_distance_R_pin]);
	dis_mid_val = filter_distance_mid(SensorValue[long_distance_M_pin]);
	dis_top_val = filter_distance_top(SensorValue[short_distance_T_pin]);

	cm_dis_mid_val = calculate_long_distance(dis_mid_val);
	cm_dis_top_val = calculate_short_distance(dis_top_val);
	cm_dis_L_val = calculate_long_distance(dis_L_val);
	cm_dis_R_val = calculate_long_distance(dis_R_val);

	d_enR = getMotorEncoder(motor_R);
	d_enL = getMotorEncoder(motor_L);
	m_rpmR = d_enR * 60/DT /ENCODER_RESOLUTION;
  m_rpmL = d_enL * 60/DT /ENCODER_RESOLUTION;

	resetMotorEncoder(motor_R);
	resetMotorEncoder(motor_L);
}

// float read_arm_position(){
//   limit_switch_A = SensorValue[limit_switch_A_pin];
//   limit_switch_B = SensorValue[limit_switch_B_pin];
//   limit_switch_C = SensorValue[limit_switch_C_pin];
// }

/**
 * @brief Initialises the robot
*/
void init(){
	resetMotorEncoder(motor_R);
	resetMotorEncoder(motor_L);
}

/**
 * @brief Simulates a robot task by floating point operations
 * @param n number of operations
*/
void floppy(int n){
	for (unsigned int i = 0; i < n; i++){
	float ans = 5.0 / 13.0;
	}
}

task main()
{
	init();
	while(1){
		clearTimer(T1);
		read_sensors();
		// Main Loop
		floppy(1000);

		while (time1[T1] < DT * 1000){}
		loop_ms = time1[T1];
	}
}
