#pragma config(Sensor, in1,    long_distance_R_pin, sensorAnalog)
#pragma config(Sensor, in2,    long_distance_M_pin, sensorAnalog)
#pragma config(Sensor, in3,    long_distance_L_pin, sensorAnalog)
#pragma config(Sensor, in4,    short_distance_T_pin, sensorAnalog)
#pragma config(Sensor, in5,    line_BR_pin,        sensorAnalog)
#pragma config(Sensor, in6,    line_FR_pin,        sensorAnalog)
#pragma config(Sensor, in7,    line_FL_pin,        sensorAnalog)
#pragma config(Sensor, in8,    line_BL_pin,        sensorAnalog)
#pragma config(Sensor, dgtl1,  wheel_L_encoderA_pin, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  wheel_R_encoderA_pin, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  limit_switch_A_pin,      sensorDigitalIn)
#pragma config(Sensor, dgtl6,  limit_switch_B_pin,      sensorDigitalIn)
#pragma config(Sensor, dgtl7,  limit_switch_C_pin,      sensorDigitalIn)
#pragma config(Sensor, dgtl8,  limit_switch_D_pin,      sensorDigitalIn)
#pragma config(Sensor, dgtl9,  magneto_west_pin,  sensorDigitalIn)
#pragma config(Sensor, dgtl10, magneto_south_pin,  sensorDigitalIn)
#pragma config(Sensor, dgtl11, magneto_east_pin,   sensorDigitalIn)
#pragma config(Sensor, dgtl12, magneto_north_pin,   sensorDigitalIn)
#pragma config(Motor,  port2,           servo,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           motor_R,       tmotorVex393_MC29, PIDControl, encoderPort, dgtl3)
#pragma config(Motor,  port7,           motor_L,       tmotorVex393_MC29, PIDControl, reversed, encoderPort, dgtl1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "odom_test.h"

#include "motor_control.c"
#include "servo_control.c"
#include "sensors.c"
#include "odometry.c"
/* _____________________________________________________________________________________________________________________

GLOBAL VARIABLES
_____________________________________________________________________________________________________________________ */

// Robot State
float robot_x = 0.0;
float robot_y = 0.0;
float robot_yaw = 0;
float robot_linX = 0;
float robot_angZ = 0.0;

float robot_arm_position = 0.0;

// robot twist
float robot_cmd_rpmR = 0.0;
float robot_cmd_rpmL = 0.0;
float robot_cmd_linX = 0.0;
float robot_cmd_angZ = 0.0;

float robot_cmd_arm_position = 0.0;
float robot_arm_direction = 0.0;

// robot encoders
float robot_en_rpmR = 0.0;
float robot_en_rpmL = 0.0;
float robot_en_linX = 0.0;
float robot_en_angZ = 0.0;

// magnetometer
float magnetometer_yaw = 0.0;

// robot line sensors
int robot_line_FL = 0;
int robot_line_BL = 0;
int robot_line_BR = 0;
int robot_line_FR = 0;

// robot distance sensors
float distance_sensor_left = 0.0;
float distance_sensor_right = 0.0;
float distance_sensor_top = 0.0;
float distance_sensor_mid = 0.0;

// limit siwtches
int limit_switch_A = 0;
int limit_switch_B = 0;
int limit_switch_C = 0;
int limit_switch_D = 0;

int loop_ms = 0;

/* _____________________________________________________________________________________________________________________

SENSORS
_____________________________________________________________________________________________________________________ */
void read_sensors(float dt){
    magnetometer_yaw = read_compass(SensorValue[magneto_north_pin], SensorValue[magneto_south_pin], SensorValue[magneto_east_pin], SensorValue[magneto_west_pin]);
    magnetometer_yaw = wrap_to_pi(magnetometer_yaw - MAGNETOMETER_OFFSET);

    limit_switch_A = SensorValue[limit_switch_A_pin];
    limit_switch_B = SensorValue[limit_switch_B_pin];
    limit_switch_C = SensorValue[limit_switch_C_pin];
    limit_switch_D = SensorValue[limit_switch_D_pin];

	robot_line_FL = check_threshold(filter_line_FL(SensorValue[line_FL_pin]), LINE_FL_THRESHOLD);
	robot_line_BL = check_threshold(filter_line_BL(SensorValue[line_BL_pin]), LINE_BL_THRESHOLD);
	robot_line_BR = check_threshold(filter_line_BR(SensorValue[line_BR_pin]), LINE_BR_THRESHOLD);
	robot_line_FR = check_threshold(filter_line_FR(SensorValue[line_FR_pin]), LINE_FR_THRESHOLD);

	distance_sensor_mid = calculate_long_distance(filter_distance_mid(SensorValue[long_distance_M_pin])) - MID_SENSOR_OFFSET;
	distance_sensor_top = calculate_short_distance(filter_distance_top(SensorValue[short_distance_T_pin])) - TOP_SENSOR_OFFSET;
	distance_sensor_left = calculate_long_distance(filter_distance_L(SensorValue[long_distance_L_pin])) - LEFT_SENSOR_OFFSET;
	distance_sensor_right = calculate_long_distance(filter_distance_R(SensorValue[long_distance_R_pin])) - RIGHT_SENSOR_OFFSET;

    robot_en_rpmL = getMotorEncoder(motor_L) * 60/dt /ENCODER_RESOLUTION;
	robot_en_rpmR = getMotorEncoder(motor_R) * 60/dt /ENCODER_RESOLUTION;

    // TEST CODE BEGIN
    robot_en_linX = calculate_linear_x(robot_en_rpmL, robot_en_rpmR);
    robot_en_angZ = calculate_angular_z(robot_en_rpmL, robot_en_rpmR);
    // TEST CODE END

	robot_arm_position = get_arm_position(robot_arm_position,robot_cmd_arm_position, robot_arm_direction, SensorValue[limit_switch_A_pin], SensorValue[limit_switch_B_pin], SensorValue[limit_switch_C_pin]);

	resetMotorEncoder(motor_R);
	resetMotorEncoder(motor_L);
	return;
}

void update_robot_odom(float dt){
    robot_x = update_odometry_x(robot_x, robot_yaw, robot_linX, robot_en_rpmL, robot_en_rpmR, dt);
    robot_y = update_odometry_y(robot_y, robot_yaw, robot_linX, robot_en_rpmL, robot_en_rpmR, dt);
    robot_yaw = update_odometry_yaw(robot_yaw, robot_angZ, robot_en_rpmL, robot_en_rpmR, magnetometer_yaw, dt);
    robot_linX = update_odometry_linX(robot_linX, robot_en_rpmL, robot_en_rpmR, dt);
    robot_angZ = update_odometry_angZ(robot_cmd_angZ, robot_en_rpmL, robot_en_rpmR, dt);
    return;
}

void robot_execute(float dt){
	robot_cmd_rpmL = calculate_rpmL(robot_cmd_linX, robot_cmd_angZ);
	robot_cmd_rpmR = calculate_rpmR(robot_cmd_linX, robot_cmd_angZ);
	robot_cmd_rpmL = limit_rpmL(robot_cmd_rpmL, robot_cmd_rpmR);
	robot_cmd_rpmR = limit_rpmR(robot_cmd_rpmL, robot_cmd_rpmR);
	robot_move_closed(robot_cmd_rpmL, robot_cmd_rpmR, robot_en_rpmL, robot_en_rpmR, dt);
	robot_cmd_linX = calculate_linear_x(robot_cmd_rpmL, robot_cmd_rpmR);
	robot_cmd_angZ = calculate_angular_z(robot_cmd_rpmL, robot_cmd_rpmR);

	robot_arm_direction = robot_arm_move(robot_cmd_arm_position, robot_arm_position);
	return;
}

/* _____________________________________________________________________________________________________________________

TASKS
_____________________________________________________________________________________________________________________ */

/**
 * @brief Initialises the robot
*/
void init_robot(){
	// Reset odom
	robot_x = 0.0;
	robot_y = 0.0;
	robot_yaw = 0.0;
	robot_linX = 0.0;
	robot_angZ = 0.0;
	robot_arm_position;
	return;
}

// TEST CODE BEGIN
// moves robot forward by a distance in [metre]
float move_distance(float distance_forward){
	if (distance_forward < 0){
		if (robot_x > distance_forward){
			return sgn(distance_forward - robot_x) * MAX_SPEED;
		}
	return 0.0;
	}
	else{
    if (robot_x < distance_forward){
        return sgn(distance_forward - robot_x) * MAX_SPEED;
		}
		return 0.0;
    }
}

// rotates the robot to face angle
float rotate_angle(float desired_yaw){
	float direction = sgn(wrap_to_pi(desired_yaw - robot_yaw));
    if (fabs(desired_yaw - robot_yaw) < YAW_TOLERANCE){
        return 0.0;
    }
    // return 0.1 * sgn(direction) * MAX_TURN;
    return direction * M_PI/4 / DEGREE_TO_RADIAN;
}
// TEST CODE END

task robot_read(){
	while(1){
		clearTimer(T2);
		read_sensors(DT_READ);
		update_robot_odom(DT_READ);
        robot_execute(DT_READ);
		while (time1[T2] < DT_READ * 1000){}
	}
}

task main()
{
	init_robot();
	clearTimer(T3);
	int dir = 1;
	float osc = 90.0;
	float Kp = 0.80;
	startTask(robot_read);
	while(1){
		clearTimer(T1);
		// main Loop

        // robot_cmd_linX = move_distance(-0.3);
        // robot_cmd_angZ = rotate_angle(0.0);

		// robot_cmd_linX = 0.0;

		// osc == oscillation
		// if (robot_yaw < osc && dir == 1){
		// 	robot_cmd_angZ = Kp * (osc - robot_yaw);
		// }
		// if (robot_yaw > osc){
		// 	dir = -1;
		// }

		// if (robot_yaw > -osc && dir == -1){
		// 	robot_cmd_angZ = Kp * (-osc - robot_yaw);
		// }
		
		// if (robot_yaw < -osc){
		// 	dir = 1;
		// }

		// robot_move_closed(-60, 60, robot_en_rpmL, robot_cmd_rpmR);
		robot_cmd_arm_position = 90.0;

        // end of main loop
		loop_ms = time1[T1];
		while (time1[T1] < DT_MAIN * 1000){}
	}
}
