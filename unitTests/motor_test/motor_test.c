#pragma config(Sensor, in1,    long_distance_R_pin, sensorAnalog)
#pragma config(Sensor, in2,    long_distance_M_pin, sensorAnalog)
#pragma config(Sensor, in3,    long_distance_L_pin, sensorAnalog)
#pragma config(Sensor, in4,    short_distance_T_pin, sensorAnalog)
#pragma config(Sensor, in5,    line_BR_pin,        sensorAnalog)
#pragma config(Sensor, in6,    line_FR_pin,        sensorAnalog)
#pragma config(Sensor, in7,    line_FL_pin,        sensorAnalog)
#pragma config(Sensor, in8,    line_BL_pin,        sensorAnalog)
#pragma config(Sensor, dgtl1,  wheel_L_encoderA_pin, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  wheel_R_encoderA_pin, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  limit_switch_A_pin,      sensorDigitalIn)
#pragma config(Sensor, dgtl6,  limit_switch_B_pin,      sensorDigitalIn)
#pragma config(Sensor, dgtl7,  limit_switch_C_pin,      sensorDigitalIn)
#pragma config(Sensor, dgtl8,  limit_switch_D_pin,      sensorDigitalIn)
#pragma config(Sensor, dgtl9,  magneto_west_pin,  sensorDigitalIn)
#pragma config(Sensor, dgtl10, magneto_south_pin,  sensorDigitalIn)
#pragma config(Sensor, dgtl11, magneto_east_pin,   sensorDigitalIn)
#pragma config(Sensor, dgtl12, magneto_north_pin,   sensorDigitalIn)
#pragma config(Motor,  port2,           servo,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           motor_R,       tmotorVex393_MC29, PIDControl, encoderPort, dgtl3)
#pragma config(Motor,  port7,           motor_L,       tmotorVex393_MC29, PIDControl, reversed, encoderPort, dgtl1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "motor_test.h"
#include "motor_control.c"
#include "servo_control.c"

/*
Note the following:
1. This file is used to TEST and CALIBRATE the motors of the drive system and the servo
2. The parameters to calibrate are located in motor_test.h and the following are to be calibrated
	- MOTOR_L_KP
	- MOTOR_L_KI
	- MOTOR_L_KD
	- MOTOR_R_KP
	- MOTOR_R_KI
	- MOTOR_R_KD
	- SERVO_ARM_TOLERANCE = the tolerance of the arm's position. it is used to determine if the servo motor should stop. 
	- SERVO_POSITION_GAIN = the estimated angle of displacement when the servo is activated in one cycle. i.e. in 0.05 [s] how much does the arm move
	- SWITCH_A_POSITION = the position of the limit switch A which is somewhere in the outward position
	- SWITCH_B_POSITION = the position of the limit switch B which is somewhere in the middle position
	- SWITCH_C_POSITION = the position of the limit switch C which is somewhere in the inward position
2. 	IMPORTANT!! The characteristic of the motor and the code sets up the KI value to be the most important. The higher the 
	value, the faster steady state speed is achieved but too high will cause oscillations. please observe the integral component the PID
3. Code found between the TEST_CODE_BEGIN and TEST_CODE_END are strictly for testing and not to be used in the final robot
*/
/* _____________________________________________________________________________________________________________________

GLOBAL VARIABLES
_____________________________________________________________________________________________________________________ */

// Robot State
float robot_x = 0.0;
float robot_y = 0.0;
float robot_yaw = 0;
float robot_linX = 0;
float robot_angZ = 0.0;

float robot_arm_position = 0.0;

// robot twist
float robot_cmd_rpmL = 0.0;
float robot_cmd_rpmR = 0.0;
float robot_cmd_linX = 0.0;
float robot_cmd_angZ = 0.0;

float robot_cmd_arm_position = 0.0;
float robot_arm_direction = 0.0;

// robot encoders
float robot_en_rpmR = 0.0;
float robot_en_rpmL = 0.0;
float robot_en_linX = 0.0;
float robot_en_angZ = 0.0;

// magnetometer
float magnetometer_yaw = 0.0;

// robot line sensors
int robot_line_FL = 0;
int robot_line_BL = 0;
int robot_line_BR = 0;
int robot_line_FR = 0;

// robot distance sensors
float distance_sensor_left = 0.0;
float distance_sensor_right = 0.0;
float distance_sensor_top = 0.0;
float distance_sensor_mid = 0.0;

// limit siwtches
int limit_switch_A = 0;
int limit_switch_B = 0;
int limit_switch_C = 0;
int limit_switch_D = 0;

static int loop_ms;

// Updates all sensor values
void read_sensors(void){
    limit_switch_A = SensorValue[limit_switch_A_pin];
    limit_switch_B = SensorValue[limit_switch_B_pin];
    limit_switch_C = SensorValue[limit_switch_C_pin];
	limit_switch_D = SensorValue[limit_switch_D_pin];

	robot_en_rpmR = getMotorEncoder(motor_R) / ENCODER_RESOLUTION * 60.0/DT;
	robot_en_rpmL = getMotorEncoder(motor_L) / ENCODER_RESOLUTION * 60.0/DT;

	// TESTING CODE BEGIN
	robot_en_linX = calculate_linear_x(robot_en_rpmR, robot_en_rpmR);
	robot_en_angZ = calculate_angular_z(robot_en_rpmR, robot_en_rpmL);
	// TESTING CODE END

	resetMotorEncoder(motor_R);
	resetMotorEncoder(motor_L);
}

/// @brief Executes the `cmd` variables
void robot_execute(){
	robot_cmd_rpmL = calculate_rpmL(robot_cmd_linX, robot_cmd_angZ);
	robot_cmd_rpmR = calculate_rpmR(robot_cmd_linX, robot_cmd_angZ);
	robot_cmd_rpmL = limit_rpmL(robot_cmd_rpmL, robot_cmd_rpmR);
	robot_cmd_rpmR = limit_rpmR(robot_cmd_rpmL, robot_cmd_rpmR);
	robot_move_closed(robot_cmd_rpmL, robot_cmd_rpmR, robot_en_rpmL, robot_en_rpmR);
	robot_cmd_linX = calculate_linear_x(robot_cmd_rpmL, robot_cmd_rpmR);
	robot_cmd_angZ = calculate_angular_z(robot_cmd_rpmL, robot_cmd_rpmR);

	robot_arm_position = get_arm_position(robot_arm_position, robot_arm_direction,limit_switch_A,limit_switch_B, limit_switch_C);
	robot_arm_direction = robot_arm_move(robot_cmd_arm_position, robot_arm_position);
}
/**
 * @brief Initialises the robot
*/
void init(){
	int ready = 0;
	while (ready != 1){
		read_sensors();
		// Init arm
		robot_arm_direction = robot_arm_move(0.0, robot_arm_position);

		robot_x = 0.0;
		robot_y = 0.0;

		// Ready criteria
		if (robot_arm_position < SERVO_TOLERANCE){
			ready = 1;
			break;
		}
	}
}

// TEST CODE BEGIN
/**
 * @brief Simulates a robot task by floating point operations
 * @param n number of operations
*/
void floppy(int n){
	for (int i = 0; i < n; i++){
	float ans = 5.0 / 13.0;
	}
}

/**
 * @brief Sets the motor to a constant power
 * @param motor_power_R The right motor power -127 to 127
 * @param motor_power_L The left motor power -127 to 127
*/
void constant_power(int motor_power_R, int motor_power_L){
	motor[motor_R] = motor_power_R;
	motor[motor_L] = motor_power_L;
	return;
}

/** 
 * @brief Sets the motors to a constant speed and updates the commanded rpm and speeds based on limitations
 * @param linX desired linear velocity in M/S
 * @param angZ desired angular velocity in DEG/S
*/
void constant_speed(float linX, float angZ){
	robot_cmd_linX = linX;
	robot_cmd_angZ = angZ;
	return;
}

/**
 * @brief Sets the motors to a constant RPM and updates the commanded RPM based on limitations. This is only for TESTING
 * @param rpmL desired LEFT wheel rpm
 * @param rpmR desired RIGHT wheel rpm
*/
void constant_rpm(float rpmL, float rpmR){
	robot_move_closed(rpmL, rpmR, robot_en_rpmL, robot_en_rpmR);
	robot_cmd_rpmL = rpmL;
	robot_cmd_rpmR = rpmR;
	robot_cmd_linX = calculate_linear_x(rpmL, rpmR);
	robot_cmd_angZ = calculate_angular_z(rpmL, rpmR);
	return;
}
// TEST CODE END

task main()
{
	init();
	while(1){
		read_sensors();
		robot_execute();
		clearTimer(T1);
		// Main Loop

		floppy(1000);

		/*________________________________________

		DRIVE MOTOR TESTING
		________________________________________*/		
		// constant_power(20, 0);
		constant_rpm(60, 60);
		// constant_speed(0.4, 0.4);

		/*________________________________________

		SERVO MOTOR TESTING
		________________________________________*/		

		// set a position
		robot_cmd_arm_position = 0.0;
	

		while (time1[T1] < DT * 1000){}
		loop_ms = time1[T1];
	}
}
