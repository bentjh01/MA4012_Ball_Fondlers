#pragma config(Sensor, in1,    long_distance_R, sensorAnalog)
#pragma config(Sensor, in2,    short_distance, sensorAnalog)
#pragma config(Sensor, in3,    long_distance_L, sensorAnalog)
#pragma config(Sensor, in4,    long_distance_top, sensorAnalog)
#pragma config(Sensor, in5,    line_BR,        sensorAnalog)
#pragma config(Sensor, in6,    line_FR,        sensorAnalog)
#pragma config(Sensor, in7,    line_FL,        sensorAnalog)
#pragma config(Sensor, in8,    line_BL,        sensorAnalog)
#pragma config(Sensor, dgtl2,  wheel_L_encoderA, sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  wheel_R_encoderA, sensorQuadEncoder)
#pragma config(Motor,  port2,           servo,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           motor_R,       tmotorVex393_MC29, PIDControl, encoderPort, dgtl4)
#pragma config(Motor,  port7,           motor_L,       tmotorVex393_MC29, PIDControl, reversed, encoderPort, dgtl2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "localisation.h"

/* _____________________________________________________________________________________________________________________

SUPPORT FUNCTIONS
_____________________________________________________________________________________________________________________ */

float fast_inverse_sqrt(float x) {
	// Initial estimate based on bit manipulation (common for fast inverse sqrt)
	float xhalf = 0.5 * x;
	int i = *(int*) &x;  // reinterpret cast to int, not recommended for portability
	i = 0x5f355f8b - (i >> 1);  // Adjust the initial guess based on MSB of float

	// Iterate a few times using Newton-Raphson method for refinement
	float y = xhalf;
	for (int n = 0; n < 4; n++) {
		y = y * (1.5 - (x * y * y));
	}
	return y;
}

float wrap_to_pi(float angle){
    if (fabs(angle) > 180.0){
        if (angle < 0){
            return angle + 360.0;
        }
        else {
            return angle - 360.0;
        }
    }
    else{
        return angle;
    }
}

/* _____________________________________________________________________________________________________________________

GLOBAL VARIABLES
_____________________________________________________________________________________________________________________ */

// Robot pose
float robot_x;
float robot_y;
float robot_yaw;
float robot_linX;
float robot_angZ;
float robot_rpmR;
float robot_rpmL;

// robot twist
float robot_cmd_rpmR;
float robot_cmd_rpmL;
float robot_cmd_linX;
float robot_cmd_angZ;

// robot encoders
float robot_enR;
float robot_enL;
float robot_en_rpmR;
float robot_en_rpmL;
float robot_en_linX;
float robot_en_angZ;

// robot magnetometer
float robot_bearing;

// robot line sensors
int robot_line_FL;
int robot_line_BL;
int robot_line_BR;
int robot_line_FR;

/* _____________________________________________________________________________________________________________________

ROBOT STATE
_____________________________________________________________________________________________________________________ */

/**
 * @brief      Calculate pose of the robot using the state model
 * @return     predicted pose.value
 */
float predict_state_model_x(float x, float yaw, float linX, float dt){
    return x + linX * dt * cos(yaw);
}
float predict_state_model_y(float y, float yaw, float linX, float dt){
    return y + linX * dt * sin(yaw);
}
float predict_state_model_yaw(float yaw, float angZ, float dt){
    return yaw + angZ * dt;
}
float predict_state_model_linX(float prev_cmd_linX){
    return prev_cmd_linX;
}
float predict_state_model_angZ(float prev_cmd_angZ){
    return prev_cmd_angZ;
}

/**
 * @brief      Calculate pose of the robot using the encoders
 * @return     predicted pose.value
 */
float predict_state_encoders_x(float x, float yaw, int d_enR, int d_enL, float dt){
    float d_radR = d_enR / ENCODER_RESOLUTION * 2 * M_PI;
	float d_radL = d_enL / ENCODER_RESOLUTION * 2 * M_PI;
    float dx = (d_radR + d_radL) * WHEEL_DIAMETER / 4 * cos(yaw);
    return x + dx;
}
float predict_state_encoders_y(float y, float yaw, int d_enR, int d_enL, float dt){
    float d_radR = d_enR / ENCODER_RESOLUTION * 2 * M_PI;
	float d_radL = d_enL / ENCODER_RESOLUTION * 2 * M_PI;
    float dy = (d_radR + d_radL) * WHEEL_DIAMETER / 4 * sin(yaw);
    return y + dy;
}
float predict_state_encoders_yaw(float yaw, int d_enR, int d_enL, float dt){
    float d_radR = d_enR / ENCODER_RESOLUTION * 2 * M_PI;
	float d_radL = d_enL / ENCODER_RESOLUTION * 2 * M_PI;
    float dyaw = (d_radR - d_radL) * WHEEL_DIAMETER / ROBOT_TRACK;
    return yaw + dyaw;
}
float predict_state_encoders_linX(float d_enR, float d_enL, float dt){
    float d_radR = d_enR / ENCODER_RESOLUTION * 2 * M_PI;
	float d_radL = d_enL / ENCODER_RESOLUTION * 2 * M_PI;
    float dx = (d_radR + d_radL) * WHEEL_DIAMETER / 4 * cos(robot_yaw);
    float dy = (d_radR + d_radL) * WHEEL_DIAMETER / 4 * sin(robot_yaw);
    return fast_inverse_sqrt(dx*dx + dy*dy) / dt;
}
float predict_state_encoders_angZ(float d_enR, float d_enL, float dt){
    float d_radR = d_enR / ENCODER_RESOLUTION * 2 * M_PI;
	float d_radL = d_enL / ENCODER_RESOLUTION * 2 * M_PI;
    float dyaw = (d_radR - d_radL) * WHEEL_DIAMETER / ROBOT_TRACK;
    return dyaw / dt;
}

/**
 * @brief      Calculate pose of the robot using the magetometer
 * @return     predicted pose.value
 */

float predict_state_magnetometer_yaw(float bearing){
    // float d_magnetometer_yaw = bearing - prev_bearing;
    return bearing;
}

/**
 * @brief      Alpha Beta Filter
 * @return     predicted pose.value
 */

float ab_filter_update_x(float x, float y, float yaw, float linX, float angZ, float d_enR, float d_enL, float dt){
    float model_pose_x = predict_state_model_x(x, yaw, linX, dt);
    float encoder_pose_x = predict_state_encoders_x(x, yaw, d_enR, d_enL, dt);
    float encoder_x_innovation = encoder_pose_x - model_pose_x;
    float predicted_x = model_pose_x + ENCODER_FILTER_GAIN * encoder_x_innovation;
    return predicted_x;
}
float ab_filter_update_y(float x, float y, float yaw, float linX, float angZ, float d_enR, float d_enL, float dt){
    float model_pose_y = predict_state_model_y(y, yaw, linX, dt);
    float encoder_pose_y = predict_state_encoders_y(y, yaw, d_enR, d_enL, dt);
    float encoder_y_innovation = encoder_pose_y - model_pose_y;
    float predicted_y = model_pose_y + ENCODER_FILTER_GAIN * encoder_y_innovation;
    return predicted_y;
}
float ab_filter_update_yaw(float yaw, float angZ, float d_enR, float d_enL, float bearing, float dt){
    float model_pose_yaw = predict_state_model_yaw(yaw, angZ, dt);
    float encoder_pose_yaw = predict_state_encoders_yaw(yaw, d_enR, d_enL, dt);
    float magnetometer_pose_yaw = predict_state_magnetometer_yaw(bearing);
    float encoder_yaw_innovation = encoder_pose_yaw - model_pose_yaw;
    float magnetometer_yaw_innovation = magnetometer_pose_yaw - discretise_yaw(model_pose_yaw);
    float predicted_yaw = model_pose_yaw + ENCODER_FILTER_GAIN * encoder_yaw_innovation + MAGNETO_FILTER_GAIN * magnetometer_yaw_innovation;
    float wrapped_yaw = wrap_to_pi(predicted_yaw);
    return predicted_yaw;
}
float ab_filter_update_linX(float prev_cmd_linX, float d_enR, float d_enL, float dt){
    float model_pose_linX = predict_state_model_linX(prev_cmd_linX);
    float encoder_pose_linX = predict_state_encoders_linX(d_enR, d_enL, dt);
    float encoder_linear_velocity_innovation = encoder_pose_linX - model_pose_linX;
    float predicted_linX = model_pose_linX + ENCODER_FILTER_GAIN * encoder_linear_velocity_innovation;
    return predicted_linX;
}
float ab_filter_update_angZ(float prev_cmd_linX, float prev_cmd_angZ, float d_enR, float d_enL, float dt){
    float model_pose_angZ = predict_state_model_angZ(prev_cmd_angZ);
    float encoder_pose_angZ = predict_state_encoders_angZ(d_enR, d_enL, dt);
    float encoder_angular_velocity_innovation = encoder_pose_angZ - model_pose_angZ;
    float predicted_angZ = model_pose_angZ + ENCODER_FILTER_GAIN * encoder_angular_velocity_innovation;
    return predicted_angZ;
}

/* _____________________________________________________________________________________________________________________

SENSORS
_____________________________________________________________________________________________________________________ */

float read_compass(void){
  int combination = SensorValue[compassSouth] << 3 + SensorValue[compassEast]  << 2 + SensorValue[compassNorth]  << 1 + SensorValue[compassWest];
  switch (combination)
  {
  case 0b1101:
    return NORTH;
  case 0b1001:
    return NORTH_EAST;
  case 0b1011:
    return EAST;
  case 0b0011:
    return SOUTH_EAST;
  case 0b0111:
    return SOUTH;
  case 0b0110:
    return SOUTH_WEST;
  case 0b1110:
    return WEST;
  case 0b1100:
    return NORTH_WEST;
  default:
    return NULL;
  }
}

void read_sensors(){
	int prev_robot_line_FL = robot_line_FL;
	int prev_robot_line_BL = robot_line_BL;
	int prev_robot_line_BR = robot_line_BR;
	int prev_robot_line_FR = robot_line_FR;
	robot_line_FL = low_pass_filter(SensorValue[line_FL], prev_robot_line_FL, CUTOFF_LINE_FL);
	robot_line_BL = low_pass_filter(SensorValue[line_BL], prev_robot_line_BL, CUTOFF_LINE_BL);
	robot_line_BR = low_pass_filter(SensorValue[line_BR], prev_robot_line_FL, CUTOFF_LINE_BR);
	robot_line_FR = low_pass_filter(SensorValue[line_FR], prev_robot_line_FL, CUTOFF_LINE_FR);

	robot_enR = getMotorEncoder(motor_R);
	robot_enL = getMotorEncoder(motor_L);

    robot_en_rpmR = robot_enR / ENCODER_RESOLUTION * 2 * M_PI / DT;
    robot_en_rpmL = robot_enL / ENCODER_RESOLUTION * 2 * M_PI / DT;

	resetMotorEncoder(motor_R);
	resetMotorEncoder(motor_L);

    robot_bearing = read_compass();
}

void update_pose(){
    robot_x = ab_filter_update_x(robot_x, robot_y, robot_yaw, robot_linX, robot_angZ, robot_enR, robot_enL, DT);
    robot_y = ab_filter_update_y(robot_x, robot_y, robot_yaw, robot_linX, robot_angZ, robot_enR, robot_enL, DT);
    robot_yaw = ab_filter_update_yaw(robot_yaw, robot_angZ, robot_enR, robot_enL, robot_bearing, DT);
    robot_linX = ab_filter_update_linX(robot_linX, robot_enR, robot_enL, DT);
    robot_angZ = ab_filter_update_angZ(robot_linX, robot_angZ, robot_enR, robot_enL, DT);
}

/* _____________________________________________________________________________________________________________________

TASKS
_____________________________________________________________________________________________________________________ */

void init_robot(void){
	robot_x = 0;
    robot_y = 0;
    robot_yaw = 0;
    robot_linX = 0;
    robot_angZ = 0;
    robot_rpmR = 0;
    robot_rpmL = 0;
    resetMotorEncoder(motor_R);
	resetMotorEncoder(motor_L);
}


int edge_detected(){
	if (robot_line_FL > LINE_FL){
		return 1;
		} else {
		return 0;
	}
	if (robot_line_BL > LINE_BL){
		return 1;
		} else {
		return 0;
	}
	if (robot_line_BR > LINE_BR){
		return 1;
		} else {
		return 0;
	}
	if (robot_line_FR > LINE_FR){
		return 1;
		} else {
		return 0;
	}
}

int edge_avoid(){
	return 1;
}

int home(){
	int sucess = 0;
	if (sucess == 1){
		return SEARCH_BALL;
	} else {
		return HOME;
	}
}

int search_ball(){
    int sucess = 0;
	if (sucess == 1){
		return GOTO_BALL;
	} else {
		return SEARCH_BALL;
	}
}

int goto_ball(){
    int sucess = 0;
	if (sucess == 1){
		return GRAB_BALL;
	} else {
		return GOTO_BALL;
	}
}

int grab_ball(){
	int sucess = 0;
	if (sucess == 1){
		return DELIVER_BALL;
	} else {
		return GRAB_BALL;
	}
}

int deliver_ball(){
	int sucess = 0;
	if (sucess == 1){
		return HOME;
	} else {
		return DELIVER_BALL;
	}
}

task main()
{
	init_robot();
	while(1){
		clearTimer(T1);
        read_sensors();
		// main Loop
		
        // end of main loop
		while (time1[T1] < DT * 1000){}
		update_pose();
	}
}